<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8" />
    <script src="lib/cannon.js"></script>
    <script src="lib/three.js"></script>
    <script src="GameObject.js"></script>
    <script src="lib/Queue.src.js"></script>
    <script src="Pool.js"></script>
</head>
<body>
    <script>
        // create queue for all game objects in the enviroment.
        var gameObjects = [];
        let width = 50, height = 20, depth = 400, radius = 20;
        let zLimit = 200;
        var minZ = 0;

        // initialize Three enviroment.
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(60, 16.0 / 9, 0.1, 10000);
        var renderer = new THREE.WebGLRenderer({ antialias: true });
        document.body.appendChild(renderer.domElement);
        scene.add(camera);
        camera.position.set(0, 0, 10);
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        // initialize Cannon world.
        var world = new CANNON.World();
        world.gravity.set(0, -10, 0);

        // create the tube mesh without adding it to the scene.
        var CustomSinCurve = THREE.Curve.create(
           function (scale) { //custom curve constructor
               this.scale = (scale === undefined) ? 1 : scale;
           },
           function (t) { //getPoint: t is between 0-1
               var tx = 0;
               var ty = 0;
               var tz = t;
               return new THREE.Vector3(tx, ty, tz).multiplyScalar(this.scale);
           }
        );
        var path = new CustomSinCurve(500);
        var tubeGeometry = new THREE.TubeGeometry(path, 10, radius, 9, false);
        var tubeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        tubeMaterial.wireframe = true;
        var tubeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);

        // create the tube physics  without adding it to the world.
        var tubeBody = new CANNON.Body({ mass: 1 });
        var tubeCollider = new CANNON.Box(new CANNON.Vec3(width, height, depth));
        tubeBody.addShape(tubeCollider);

        // create a pool of tubes.
        var tubesPool = new Pool(tubeBody, tubeMesh);

        // call generate and update on intervals.
        setInterval(generate, 100);
        setInterval(update, 1 / 60);

        // render scene.
        renderer.setSize(900, 600);
        (function render() {
            requestAnimationFrame(render);
            renderer.render(scene, camera);
        })();
        function update() {
            for (var i = 0; i < gameObjects.length; i++) {
                if (gameObjects[i].position.z > zLimit && gameObjects[i].visible) {
                    tubesPool.returnToPool(gameObjects[i]);
                }
                if (gameObjects[i].threeBody.visible) {
                    gameObjects[i].position.z += 0.3;
                    gameObjects[i].link();
                    minZ = Math.min(minZ, gameObjects[i].position.z)
                }
            }
        }
        function generate() {
            var object = (tubesPool.getFromPool());
            addToGame(object);
            object.position.z = minZ - depth;
        }
        function addToGame(gameObjs) {

            if (gameObjs.threeBody.parent == null) {

                scene.add(gameObjs.threeBody);
                world.addBody(gameObjs.cannonBody);
                gameObjects.push(gameObjs);
            }
        }


    </script>
</body>
</html>
