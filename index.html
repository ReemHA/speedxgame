<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8" />
    <script src="lib/cannon.js"></script>
    <script src="lib/three.js"></script>
    <script src="GameObject.js"></script>
    <script src="lib/Queue.src.js"></script>
    <script src="Pool.js"></script>
</head>
<body>
    <script>
        // create queue for all game objects in the enviroment.
        var gameObjects = [];
        let tubeWidthCollider = 50, tubeHeightCollider = 20, tubeDepthCollider = 400, radius = 20;
        let zLimit = 200, obstacleWidth = 3, obstacleHeight = 1, obstacleDepth = 3;
        var minZ = 0;
        window.onkeydown = movePlayer;

        // moving in circle parameters.
        var angle = -90,
            speed = (2 * Math.PI) / 10,
            rotational_angle = 20;

        // initialize Three enviroment.
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(60, 16.0 / 9, 0.1, 10000);
        var renderer = new THREE.WebGLRenderer({ antialias: true });
        var texture = THREE.ImageUtils.loadTexture("gamepic.jpg");
        document.body.appendChild(renderer.domElement);
        scene.add(camera);
        camera.position.set(0, 0, 10);
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        // initialize Cannon world.
        var world = new CANNON.World();
        world.gravity.set(0, -10, 0);

        // create the tube mesh without adding it to the scene.
        var CustomSinCurve = THREE.Curve.create(
           function (scale) { //custom curve constructor
               this.scale = (scale === undefined) ? 1 : scale;
           },
           function (t) { //getPoint: t is between 0-1
               if (true) {
                   var tx = 0;
                   var ty = 0;
                   var tz = t;
               }
               return new THREE.Vector3(tx, ty, tz).multiplyScalar(this.scale);
           }
        );
        var path = new CustomSinCurve(500);

        var tubeGeometry = new THREE.TubeGeometry(path, 70, radius, 9, false);
        var tubeMaterial = new THREE.MeshBasicMaterial({map:texture, color: 0xd3d3d3 });
        tubeMaterial.wireframe = true;
        var tubeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);

        // create the tube physics  without adding it to the world.
        var tubeBody = new CANNON.Body({ mass: 1 });
        var tubeCollider = new CANNON.Box(new CANNON.Vec3(tubeWidthCollider, tubeHeightCollider, tubeDepthCollider));
        tubeBody.addShape(tubeCollider);

        // create a pool of tubes.
        var tubesPool = new Pool(tubeBody, tubeMesh);

        // create obstacle mesh without adding it to the scene.
        var obstacleGeometry = new THREE.BoxGeometry(obstacleWidth, obstacleHeight, obstacleDepth);
        var obstacleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        var obstacleMesh = new THREE.Mesh(obstacleGeometry, obstacleMaterial);

        // create obstacle physics without adding it to the scene.
        var obstacleBody = new CANNON.Body({ mass: 1 });
        var obstacleCollider = new CANNON.Box(new CANNON.Vec3(obstacleWidth, obstacleHeight, obstacleDepth));
        obstacleBody.addShape(obstacleCollider);

        // create a pool of obstacles.
        var obstaclePool = new Pool(obstacleBody, obstacleMesh);

        // adding the player.
        var materialplayer = new THREE.MeshBasicMaterial({ color: 0xffffff });
        var playerGeometry = new THREE.BoxGeometry(2, 2, 2);
        var player = new THREE.Mesh(playerGeometry, materialplayer);

        player.position.x = 0;
        player.position.y = -10;  //-5 //remade to follow the pattern
        player.position.z = 0;
        scene.add(player);

        // call generate and update on intervals.
        setInterval(generate, 150);
        setInterval(update, 1 / 60);

        // adding camera to the player.
        camera.position.set(player.position.x, player.position.y, player.position.z);

        // render scene.
        renderer.setSize(window.innerWidth, window.innerHeight);

        (function render() {
            requestAnimationFrame(render);
            renderer.render(scene, camera);
        })();
        function update() {
            for (var i = 0; i < gameObjects.length; i++) {
                if (gameObjects[i].position.z > zLimit && gameObjects[i].visible) {
                    tubesPool.returnToPool(gameObjects[i]);
                }
                if (gameObjects[i].threeBody.visible) {
                    gameObjects[i].position.z += 0.3;
                    gameObjects[i].link();
                    minZ = Math.min(minZ, gameObjects[i].position.z)
                }
            }
        }
        function generate() {
            var tubeObj = [];
            var obstacleObj = [];
            tubeObj.push((tubesPool.getFromPool()));
            for (var i = 0; i <= 2; i++) {
                obstacleObj[i] = obstaclePool.getFromPool();
            };
            addToGame(tubeObj);
            generatePosition(obstacleObj);
            addToGame(obstacleObj);
            for (var i = 0; i < tubeObj.length; i++) {
                tubeObj[i].position.z = minZ - tubeDepthCollider;
            };
            for (var i = 0; i < obstacleObj.length; i++) {
                obstacleObj[i].position.z = minZ - obstacleDepth;
            };
        }
        function addToGame(gameObjs) {
            for (var i = 0; i < gameObjs.length; i++) {
                if (gameObjs[i].threeBody.parent == null) {
                    scene.add(gameObjs[i].threeBody);
                    world.addBody(gameObjs[i].cannonBody);
                    gameObjects.push(gameObjs[i]);
                }
            };
            
        }

        function generatePosition(gameObjs) {
            var positionX = [-15, -8, 8, 15]
            for (var i = 0; i < gameObjs.length; i++) {
                gameObjs[i].position.set(positionX[Math.floor(Math.random() * positionX.length)], (Math.random() * 20) - 10, 0);
                //gameObjs.rotation.z = ((Math.random() * 5));
                console.log(gameObjs[i].position);
            }
        }


        // function resposible for moving the player and the camera
        function movePlayer(event) {

            //Testing
            console.log(event.keyCode);
            console.log("x" + player.position.x);
            console.log("y" + player.position.y);
            console.log("z" + player.position.z);


            switch (event.keyCode) {
                //left
                case 37:
                    // speed * delta_time
                    angle += speed * (1.0 / 6);  
                    player.position.x = Math.cos(angle) * (radius - 3);
                    player.position.y = Math.sin(angle) * (radius - 3);

                    //moving the camera
                    camera.position.set(player.position.x, player.position.y, player.position.z);
                    break;

                //right
                case 39:
                    // speed * delta_time
                    angle -= speed * (1.0 / 6);  
                    player.position.x = Math.cos(angle) * (radius - 3);
                    player.position.y = Math.sin(angle) * (radius - 3);
                    //moving the camera
                    camera.position.set(player.position.x, player.position.y, player.position.z);
                    break;
            }
        }

    </script>
</body>
</html>
